use serde::Deserialize;
use std::env;
use std::fs;
use std::path::Path;

const PAGE_SIZE: usize = 1 << 13; // 8192

fn auto_pages(size: usize) -> usize {
    if size <= PAGE_SIZE {
        1
    } else if size <= PAGE_SIZE * 4 {
        // Target ~8 objects per span
        (size * 8 + PAGE_SIZE - 1) / PAGE_SIZE
    } else {
        // Target ~2 objects per span for large classes
        (size * 2 + PAGE_SIZE - 1) / PAGE_SIZE
    }
}

fn auto_batch(size: usize) -> usize {
    if size <= 1024 {
        32
    } else if size <= 4096 {
        (65536 / size).max(2)
    } else {
        (PAGE_SIZE / size).max(2)
    }
}

struct ClassDef {
    size: usize,
    pages: usize,
    batch_size: usize,
}

fn auto_class(size: usize) -> ClassDef {
    ClassDef {
        size,
        pages: auto_pages(size),
        batch_size: auto_batch(size),
    }
}

#[derive(Deserialize, Default)]
struct Config {
    #[serde(default)]
    classes: Vec<usize>,
    #[serde(default, rename = "class")]
    class_full: Vec<ClassFull>,
}

#[derive(Deserialize)]
struct ClassFull {
    size: usize,
    pages: Option<usize>,
    batch_size: Option<usize>,
}

fn parse_config(content: &str) -> Vec<ClassDef> {
    let config: Config = toml::from_str(content).expect("failed to parse RTMALLOC_CLASSES TOML");

    if !config.classes.is_empty() && !config.class_full.is_empty() {
        panic!("RTMALLOC_CLASSES: use either `classes = [...]` or `[[class]]`, not both");
    }

    let defs: Vec<ClassDef> = if !config.classes.is_empty() {
        config.classes.iter().map(|&s| auto_class(s)).collect()
    } else if !config.class_full.is_empty() {
        config
            .class_full
            .iter()
            .map(|c| ClassDef {
                size: c.size,
                pages: c.pages.unwrap_or_else(|| auto_pages(c.size)),
                batch_size: c.batch_size.unwrap_or_else(|| auto_batch(c.size)),
            })
            .collect()
    } else {
        panic!("RTMALLOC_CLASSES: config must contain `classes` or `[[class]]` entries");
    };

    validate(&defs);
    defs
}

fn validate(defs: &[ClassDef]) {
    assert!(
        !defs.is_empty(),
        "RTMALLOC_CLASSES: no size classes defined"
    );
    assert!(
        defs.len() < 64,
        "RTMALLOC_CLASSES: too many classes ({}, max 63)",
        defs.len()
    );
    for (i, d) in defs.iter().enumerate() {
        assert!(d.size > 0, "class {}: size must be > 0", i);
        assert!(
            d.size % 8 == 0,
            "class {}: size {} must be 8-byte aligned",
            i,
            d.size
        );
        assert!(d.pages > 0, "class {}: pages must be > 0", i);
        assert!(d.batch_size > 0, "class {}: batch_size must be > 0", i);
        if i > 0 {
            assert!(
                d.size > defs[i - 1].size,
                "class {}: size {} must be > previous size {}",
                i,
                d.size,
                defs[i - 1].size
            );
        }
    }
}

fn default_config_path() -> String {
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    format!("{}/default_classes.toml", manifest_dir)
}

fn generate(defs: &[ClassDef], out_path: &Path) {
    let num_size_classes = defs.len() + 1;

    let mut code = String::from("// Auto-generated by build.rs. Do not edit.\n\n");

    // SIZE_CLASSES array: sentinel at [0], then defs at [1..]
    code.push_str(&format!(
        "pub static SIZE_CLASSES: [SizeClassInfo; {num_size_classes}] = [\n\
         \x20   SizeClassInfo {{ size: 0, pages: 0, batch_size: 0 }}, // sentinel\n",
    ));
    for d in defs {
        code.push_str(&format!(
            "    SizeClassInfo {{ size: {}, pages: {}, batch_size: {} }},\n",
            d.size, d.pages, d.batch_size
        ));
    }
    code.push_str("];\n");

    fs::write(out_path, code).expect("failed to write size_class_gen.rs");
}

fn main() {
    println!("cargo:rerun-if-env-changed=RTMALLOC_CLASSES");

    let out_dir = env::var("OUT_DIR").unwrap();
    let dest = Path::new(&out_dir).join("size_class_gen.rs");

    let config_path = env::var("RTMALLOC_CLASSES").unwrap_or_else(|_| default_config_path());
    println!("cargo:rerun-if-changed={}", config_path);
    let content = fs::read_to_string(&config_path)
        .unwrap_or_else(|e| panic!("failed to read {}: {}", config_path, e));
    let defs = parse_config(&content);

    generate(&defs, &dest);
}
