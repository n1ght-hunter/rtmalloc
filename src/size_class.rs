//! Size class table and lookup functions for tcmalloc.
//!
//! Objects are bucketed into size classes to reduce fragmentation and enable
//! free list management. The table is configured via a TOML file at build time
//! (see `default_classes.toml` and the `RTMALLOC_CLASSES` env var).

use crate::config::PAGE_SIZE;

/// Information about a single size class.
#[derive(Clone, Copy)]
pub struct SizeClassInfo {
    /// Allocation size for this class (bytes). All allocations in this class
    /// are rounded up to this size.
    pub size: usize,
    /// Number of pages per span for this class.
    pub pages: usize,
    /// Number of objects to transfer between thread cache and central cache at once.
    pub batch_size: usize,
}

impl SizeClassInfo {
    pub const fn objects_per_span(&self) -> usize {
        (self.pages * PAGE_SIZE) / self.size
    }
}

// Generated by build.rs from TOML config. Defines:
//   pub const NUM_SIZE_CLASSES: usize
//   pub const MAX_SMALL_SIZE: usize
//   pub static SIZE_CLASSES: [SizeClassInfo; NUM_SIZE_CLASSES]
include!(concat!(env!("OUT_DIR"), "/size_class_gen.rs"));

pub const NUM_SIZE_CLASSES: usize = SIZE_CLASSES.len();
pub const MAX_SMALL_SIZE: usize = SIZE_CLASSES[NUM_SIZE_CLASSES - 1].size;

/// First class index with size > 1024 (skip point for the linear scan).
/// Maximum size covered by the fast lookup table.
/// Capped at 1024 to keep the table small; sizes above this use linear scan.
const SMALL_LOOKUP_MAX: usize = const {
    if MAX_SMALL_SIZE < 1024 {
        MAX_SMALL_SIZE
    } else {
        1024
    }
};

/// Number of entries in the fast lookup table.
const SMALL_LOOKUP_LEN: usize = SMALL_LOOKUP_MAX / 8 + 1;

/// First class index with size > SMALL_LOOKUP_MAX (start of linear scan).
const FIRST_CLASS_ABOVE_LOOKUP: usize = const {
    let mut cls = 0;
    while cls < NUM_SIZE_CLASSES && SIZE_CLASSES[cls].size <= SMALL_LOOKUP_MAX {
        cls += 1;
    }
    cls
};

/// Fast lookup table: index = size.div_ceil(8), value = size class index.
static SMALL_LOOKUP: [u8; SMALL_LOOKUP_LEN] = const {
    let mut table = [0u8; SMALL_LOOKUP_LEN];
    let mut i = 0;
    while i < SMALL_LOOKUP_LEN {
        let size = if i == 0 { 0 } else { i * 8 };
        let mut cls = 1u8;
        while (cls as usize) < NUM_SIZE_CLASSES {
            if SIZE_CLASSES[cls as usize].size >= size {
                break;
            }
            cls += 1;
        }
        if (cls as usize) >= NUM_SIZE_CLASSES {
            cls = (NUM_SIZE_CLASSES - 1) as u8;
        }
        table[i] = cls;
        i += 1;
    }
    table
};

/// Map an allocation size to its size class index.
/// Returns 1 for size 0 (minimum allocation is 8 bytes).
/// Returns 0 for sizes > MAX_SMALL_SIZE (large allocation).
#[inline]
pub const fn size_to_class(size: usize) -> usize {
    if size == 0 {
        return 1;
    }
    if size > MAX_SMALL_SIZE {
        return 0;
    }
    if size <= SMALL_LOOKUP_MAX {
        let idx = size.div_ceil(8);
        return SMALL_LOOKUP[idx] as usize;
    }
    // Linear scan for sizes above the lookup table.
    let mut cls = FIRST_CLASS_ABOVE_LOOKUP;
    while cls < NUM_SIZE_CLASSES {
        if SIZE_CLASSES[cls].size >= size {
            return cls;
        }
        cls += 1;
    }
    0
}

/// Get the allocation size for a given size class.
#[inline]
pub const fn class_to_size(cls: usize) -> usize {
    SIZE_CLASSES[cls].size
}

/// Get the size class info for a given class index.
#[inline]
pub const fn class_info(cls: usize) -> &'static SizeClassInfo {
    &SIZE_CLASSES[cls]
}

/// Maximum allocation size handled by size classes.
#[inline]
pub const fn max_small_size() -> usize {
    MAX_SMALL_SIZE
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_size_to_class_zero() {
        let cls = size_to_class(0);
        assert_eq!(cls, 1);
        assert_eq!(class_to_size(cls), 8);
    }

    #[test]
    fn test_size_to_class_exact() {
        assert_eq!(class_to_size(size_to_class(8)), 8);
        assert_eq!(class_to_size(size_to_class(16)), 16);
        assert_eq!(class_to_size(size_to_class(64)), 64);
        assert_eq!(class_to_size(size_to_class(128)), 128);
        assert_eq!(class_to_size(size_to_class(256)), 256);
        assert_eq!(class_to_size(size_to_class(512)), 512);
        assert_eq!(class_to_size(size_to_class(1024)), 1024);
        assert_eq!(class_to_size(size_to_class(2048)), 2048);
        assert_eq!(class_to_size(size_to_class(4096)), 4096);
        assert_eq!(class_to_size(size_to_class(8192)), 8192);
        assert_eq!(class_to_size(size_to_class(262144)), 262144);
    }

    #[test]
    fn test_size_to_class_rounds_up() {
        assert_eq!(class_to_size(size_to_class(1)), 8);
        assert_eq!(class_to_size(size_to_class(7)), 8);
        assert_eq!(class_to_size(size_to_class(9)), 16);
        assert_eq!(class_to_size(size_to_class(15)), 16);
        assert_eq!(class_to_size(size_to_class(17)), 24);
        assert_eq!(class_to_size(size_to_class(65)), 80);
        assert_eq!(class_to_size(size_to_class(129)), 160);
        assert_eq!(class_to_size(size_to_class(257)), 320);
        assert_eq!(class_to_size(size_to_class(1025)), 1280);
    }

    #[test]
    fn test_size_to_class_large() {
        assert_eq!(size_to_class(MAX_SMALL_SIZE + 1), 0);
        assert_eq!(size_to_class(1_000_000), 0);
    }

    #[test]
    fn test_round_trip_all_classes() {
        for cls in 1..NUM_SIZE_CLASSES {
            let size = class_to_size(cls);
            assert!(size > 0, "class {} has zero size", cls);
            let found = size_to_class(size);
            assert_eq!(
                found, cls,
                "round-trip failed for class {} (size {})",
                cls, size
            );
        }
    }

    #[test]
    fn test_classes_monotonically_increasing() {
        for i in 2..NUM_SIZE_CLASSES {
            assert!(
                SIZE_CLASSES[i].size > SIZE_CLASSES[i - 1].size,
                "class {} size {} not greater than class {} size {}",
                i,
                SIZE_CLASSES[i].size,
                i - 1,
                SIZE_CLASSES[i - 1].size
            );
        }
    }

    #[test]
    #[allow(clippy::needless_range_loop)]
    fn test_all_sizes_8_aligned() {
        for cls in 1..NUM_SIZE_CLASSES {
            assert_eq!(
                class_to_size(cls) % 8,
                0,
                "class {} size {} not 8-aligned",
                cls,
                class_to_size(cls)
            );
        }
    }

    #[test]
    #[allow(clippy::needless_range_loop)]
    fn test_objects_per_span() {
        for cls in 1..NUM_SIZE_CLASSES {
            let info = class_info(cls);
            let objs = info.objects_per_span();
            assert!(objs >= 1, "class {} has 0 objects per span", cls);
            assert!(objs * info.size <= info.pages * PAGE_SIZE);
        }
    }

    #[test]
    fn test_num_size_classes() {
        assert_eq!(NUM_SIZE_CLASSES, SIZE_CLASSES.len());
    }

    #[test]
    fn test_max_small_size() {
        assert_eq!(MAX_SMALL_SIZE, class_to_size(NUM_SIZE_CLASSES - 1));
    }
}
